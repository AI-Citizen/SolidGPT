"""everything in workgraph can be considered as global"""
import os
import time
from solidgpt.saveload.saveload import *

# Path to the folder you want to create
output_folder_path = "out"


class WorkGraph:

    nodes: list[WorkNode] = []
    node_map: dict[int, WorkNode] = {}
    output_map: dict[int, SkillOutput] = {}
    output_id_to_node_map: dict[int, WorkNode] = {}

    def __init__(self):
        # need to manually initialize here
        self.nodes = []
        self.node_map = {}
        self.output_map = {}
        self.output_id_to_node_map = {}
        if not os.path.exists(output_folder_path):
            # Create the output folder
            os.makedirs(output_folder_path)
            print(f"Folder '{output_folder_path}' created.")
        else:
            print(f"Folder '{output_folder_path}' already exists. You may want to delete it first.")
        return

    def add_node(self, node: WorkNode):
        self.nodes.append(node)

    def init_node_dependencies(self):

        # clear node map and output map
        self.node_map.clear()
        self.output_map.clear()
        self.output_id_to_node_map.clear()

        for node in self.nodes:
            # add node to node map
            self.node_map[node.node_id] = node

            # create directory for node
            node_folder_path = output_folder_path + "/" + str(node.node_id)
            if not os.path.exists(node_folder_path):
                # Create the output folder
                os.makedirs(node_folder_path)
                print(f"Folder '{node_folder_path}' created.")
            else:
                print(f"Folder '{node_folder_path}' already exists. You may want to delete it first.")

            # add output to output map
            for o in node.agent.skill.outputs:
                # initialize output paths
                o.param_path = node_folder_path + "/" + (o.param_name + " " + str(o.id)).replace(" ", "_")
                # output can be consumed by inputs of other nodes
                if o.id >= 0:
                    self.output_map[o.id] = o
                    self.output_id_to_node_map[o.id] = node

        # second iteration after output map has been initialized
        for node in self.nodes:
            # add output dependencies for node
            for i in node.agent.skill.inputs:
                if i.loading_method == SkillInputLoadingMethod.LOAD_FROM_OUTPUT_ID:
                    if i.load_from_output_id == -1:
                        print("Error, " + i.param_name + ": cannot load from output id: -1.")
                        continue
                    node.output_id_dependencies.add(i.load_from_output_id)

                    # add current node to next_node_ids of the output node
                    if i.load_from_output_id not in self.output_map:
                        print("Error, input %s: loading from an invalid output id %d."
                              % (i.param_name, i.load_from_output_id))
                        continue
                    output_node = self.output_id_to_node_map[i.load_from_output_id]
                    if output_node.node_id == node.node_id:
                        print("Error, " + i.param_name + ": cannot load from its own output.")
                        continue
                    output_node.next_node_ids.add(node.node_id)
                    i.skill_output = self.output_map[i.load_from_output_id]

        if self.__is_circular():
            print_error_message("Circular graph detected. Terminating program...")
            exit(1)
        return

    def execute(self):
        print("Executing SolidGPT...")
        for node in self.nodes:
            self.__execute_node(node)

    def __execute_node(self, node: WorkNode):
        if node.can_execute():
            # execute skill
            node.agent.skill.execute()
            # wait for potential node pause
            self.__node_pause(node)
            # notify other nodes
            for next_node_id in node.next_node_ids:
                next_node = self.node_map[next_node_id]
                for o in node.agent.skill.outputs:
                    next_node.output_id_dependencies.remove(o.id)
                self.__execute_node(next_node)

    def __node_pause(self, node: WorkNode):
        if node.manual_review_result:
            time.sleep(0.25)
            print("\nPlease review result generated by %s agent's %s skill in node %s"
                  % (node.agent.name, node.agent.skill.name, str(node.node_id)))
            while True:
                user_input = input("Execution is halted. Please specify an action, then press Enter. "
                                   "To view all available actions, enter 'help':")

                if same_string(user_input, "help"):
                    help_msg: str = "{:<18}{}\n".format("help", "Show this help message.") + \
                                    "{:<18}{}\n".format("continue", "Continue execution.") + \
                                    "{:<18}{}\n".format("stop", "Stop program.") + \
                                    "{:<18}{}\n".format("path", "Show the path of this result.")
                    print(help_msg)
                    continue
                elif same_string(user_input, "continue"):
                    print("Continuing execution...")
                    break
                elif same_string(user_input, "stop"):
                    print("Exiting the program...")
                    exit(0)
                elif same_string(user_input, "path"):
                    print(os.path.abspath(os.path.dirname(node.agent.skill.outputs[0].param_path)))
                    continue
                else:
                    print("Invalid input entered.")
                    continue

    def save_data(self, filename: str = "data.json", generate_debug_info: bool = False):
        save_data = generate_save_data_from_nodes(self.nodes, generate_debug_info)
        save_to_json(save_data, filename)
        return

    def load_data(self, filename: str = "data.json"):
        loaded_data = load_from_json(filename)
        self.nodes.clear()
        self.nodes = load_save_data_to_nodes(loaded_data)
        self.init_node_dependencies()
        return

    def __is_circular(self):
        visited = {node_id: False for node_id in self.node_map}
        stack = {node_id: False for node_id in self.node_map}

        # check every node because the graph might be disjoint
        for node_id in self.node_map:
            if not visited[node_id]:
                if self.__has_cycle(node_id, visited, stack):
                    return True

        return False

    def __has_cycle(self, current_node_id, visited, stack):
        # mark the current node as visited
        visited[current_node_id] = True
        # add the current node to the stack representing the current path
        stack[current_node_id] = True

        # visit all the neighbors of the current node
        for neighbor_id in self.node_map[current_node_id].next_node_ids:
            # if the neighbor is not visited, visit it
            if not visited[neighbor_id]:
                if self.__has_cycle(neighbor_id, visited, stack):
                    return True
            # if the neighbor is already in the current path, we have found a cycle
            elif stack[neighbor_id]:
                return True

        # remove the current node from the current path stack
        stack[current_node_id] = False
        return False
